/**************************************************************************************************\
 *** 
 *** Simulink model       : BionicHand_r
 *** TargetLink subsystem : BionicHand_r/fingerCtrl
 *** Codefile             : fingerCtrl.c
 ***
 *** Generated by TargetLink, the dSPACE production quality code generator
 *** Generation date: 2021-06-08 10:57:06
 ***
 *** CODE GENERATOR OPTIONS:
 *** Code generation mode                     : Standard
 *** Compiler                                 : <unknown>
 *** Target                                   : Generic
 *** ANSI-C compatible code                   : yes
 *** Code Optimization                        : enabled
 *** Constant style                           : decimal
 *** Clean code option                        : enabled
 *** Logging mode                             : Do not log anything
 *** Code Coverage                            : disabled
 *** Generate empty conditional branches      : disabled
 *** Loop unroll threshold                    : 5
 *** Utilize bitwise shift operations         : AvoidPotentiallyUndefinedShiftsBasedOnSignedness
 *** Handle unscaled SF expr. with TL type    : enabled
 *** Assignment of conditions                 : AllBooleanOutputs 
 *** Scope reduction only to function level   : disabled
 *** Exploit ranges if not erasable           : disabled
 *** Exploit Compute Through Overflow         : optimized
 *** Linker sections                          : enabled
 *** Enable Assembler                         : disabled
 *** Variable name length                     : 31 chars
 *** Use global bitfields                     : disabled
 *** Stateflow: use of bitfields              : enabled
 *** State activity encoding limit            : 5
 *** Omit zero inits in restart function      : disabled
 *** Share functions between TL subsystems    : disabled
 *** Generate 64bit functions                 : disabled
 *** Inlining Threshold                       : 6
 *** Line break limit                         : 100
 *** Target optimized boolean data type       : enabled
 *** Keep saturation elements                 : disabled
 *** Extended variable sharing                : disabled
 *** Extended lifetime optimization           : enabled
 *** Style definition file                    : C:\Appl\dSpace\dSPACE TargetLink 5.1\Matlab\Tl\Confi
 ***                                            g\codegen\cconfig.xml
 *** Root style sheet                         : C:\Appl\dSpace\dSPACE TargetLink 5.1\Matlab\Tl\XML\C
 ***                                            odeGen\Stylesheets\TL_CSourceCodeSS.xsl
 ***
 *** SUBSYS         CORRESPONDING SIMULINK SUBSYSTEM
 *** Se1            fingerCtrl
 *** Se2            fingerCtrl/Abschaltung
 *** Se3            fingerCtrl/DetectChange_TL
 *** Se4            fingerCtrl/FF
 *** Se5            fingerCtrl/I
 *** Se6            fingerCtrl/Integrator
 *** Se7            fingerCtrl/Integrator1
 *** Se8            fingerCtrl/KI_reduction
 *** Se9            fingerCtrl/Kraft - Druck Umrechnung
 *** Se10           fingerCtrl/P
 *** Se11           fingerCtrl/Subsystem
 *** Se12           fingerCtrl/bahnplaner
 *** Se13           fingerCtrl/bar2Pa
 *** Se14           fingerCtrl/reOrderSignals
 *** Se15           fingerCtrl/Integrator1/Saturate
 *** Se16           fingerCtrl/bahnplaner/DetectChange_TL
 *** Se17           fingerCtrl/bahnplaner/DetectChange_TL1
 *** Se18           fingerCtrl/bahnplaner/DetectChange_TL2
 *** Se19           fingerCtrl/bahnplaner/Subsystem
 *** Se20           fingerCtrl/bahnplaner/Subsystem1
 *** Se21           fingerCtrl/bahnplaner/Subsystem/Integrator
 *** Se22           fingerCtrl/bahnplaner/Subsystem1/Integrator
 *** 
 *** SUBSYS         CORRESPONDING MODEL BLOCK (REFERENCED MODEL)
 *** 
 *** SF-NODE        CORRESPONDING STATEFLOW NODE                    DESCRIPTION
 *** 
 *** TargetLink version      : 5.1 from 28-Oct-2020
 *** Code generator version  : Build Id 5.1.0.29 from 2020-10-22 12:32:14
\**************************************************************************************************/

#ifndef FINGERCTRL_C
#define FINGERCTRL_C

/*------------------------------------------------------------------------------------------------*\
  DEFINES (OPT)
\*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*\
  INCLUDES
\*------------------------------------------------------------------------------------------------*/

#include <math.h>
#include "tl_limits.h"
#include "fingerCtrl.h"

#ifdef __cplusplus
extern "C" {
#endif

/*------------------------------------------------------------------------------------------------*\
  ENUMS
\*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*\
  DEFINES
\*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*\
  TYPEDEFS
\*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*\
  VARIABLES
\*------------------------------------------------------------------------------------------------*/

/**************************************************************************************************\
   CAL: global calibratable parameters (ROM) | Width: N.A.
\**************************************************************************************************/
CAL struct finger_tuning_tag fingerCtrl_tuning_a = {
   0.5F, /* P_big */
   0.20000000298023224F, /* P_small */
   0.10000000149011612F, /* I_big */
   0.10000000149011612F, /* I_small */
   1.1000000238418579F, /* FF_big */
   0.5F, /* FF_small */
   {
      /* [0..4] */ 508, 1615, 1340, 1350, 1345
      /* 508., 1615., 1340., 1350., 1345. */
   }, /* minTopFingerPos */
   {
      /* [0..4] */ 1780, 1840, 1800, 1680, 1730
      /* 1780., 1840., 1800., 1680., 1730. */
   }, /* minBotFingerPos */
   {
      /* [0..4] */ 205, 760, 150, 670, 910
      /* 205., 760., 150., 670., 910. */
   }, /* maxTopFingerPos */
   {
      /* [0..4] */ 780, 745, 750, 690, 630
      /* 780., 745., 750., 690., 630. */
   }, /* maxBotFingerPos */
   {
      /* [0..1] */ 15.F, 0.5F
      /* 15.F, 0.5F */
   }, /* P_cyl_drvs */
   {
      /* [0..1] */ 50.F, 1.F
      /* 50.F, 1.F */
   }, /* I_cyl_drvs */
   {
      /* [0..1] */ 3.F, 0.F
      /* 3.F, 0.F */
   }, /* FF_cyl_drvs */
   1220, /* cyl1_minPos */
   2800, /* cyl1_maxPos */
   930, /* DRVS_minPos */
   815 /* DRVS_maxPos */
};

/*------------------------------------------------------------------------------------------------*\
  PARAMETERIZED MACROS
\*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*\
  FUNCTION PROTOTYPES
\*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*\
  INLINE FUNCTIONS
\*------------------------------------------------------------------------------------------------*/
/*------------------------------------------------------------------------------------------------*\
  FUNCTION DEFINITIONS
\*------------------------------------------------------------------------------------------------*/

/**************************************************************************************************\
 ***  FUNCTION:
 ***      fingerCtrl
 *** 
 ***  DESCRIPTION:
 ***      
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***      Float32            Se1_TopFingerSensors[5] TopFinger Sensor Values UInt16
 ***      Float32            Se1_BotFingerSensors[5] BottomFinger Sensor Values UInt16
 ***      Float32            Se1_desFingerPos[7] desired Finger Position (0-1)
 ***      Bool *             Se1_reset           reset Controller (Integral Part)
 ***      UInt16 *           ActPos_cyl1         sensor signal cylinder 1 in increments
 ***      UInt16 *           ActPos_DRVS         sensor signal DRVS in increments
 ***      Float32 *          desPos_cyl1         desired position cylinder 1 (0-1)
 ***      Float32 *          desPos_DRVS         desired position DRVS (0-1)
 ***      Bool *             enable              enable/reset
 ***      Float32            Se1_pFinger_des[7]  desired pressures [Pa]
[thumb_top, thumb_bot,index_top,index_bot,middle,ring,small]
 ***      Float32 *          p2d_cyl1            desired pressure at port 2 of cylinder 1 (index)
 ***      Float32 *          p2d_DRVS            desired pressure at port 2 of DRVS
 ***      const struct finger_tuning_tag * fingerCtrl_tuning
 ***
 ***  RETURNS:
 ***      void
 ***
 ***  SETTINGS:
 ***
\**************************************************************************************************/
void fingerCtrl(Float32 Se1_TopFingerSensors[5], Float32 Se1_BotFingerSensors[5], Float32
  Se1_desFingerPos[7], Bool * Se1_reset, UInt16 * ActPos_cyl1, UInt16 * ActPos_DRVS, Float32 *
  desPos_cyl1, Float32 * desPos_DRVS, Bool * enable, Float32 Se1_pFinger_des[7], Float32 * p2d_cyl1,
  Float32 * p2d_DRVS, const struct finger_tuning_tag * fingerCtrl_tuning)
{
   /* STATIC_LOCAL: static local variables (RAM) | Width: N.A. */
   STATIC_LOCAL struct finger_const_tag finger_const = {
      0.F, /* useMean */
      5.F, /* ctrlGain */
      0.5F, /* rateLim_finger */
      {
         /* [0..1] */ 8.4823004726786166e-05F, 5.8333336028226768e-07F
         /* 8.4823004726786166e-05F, 5.8333336028226768e-07F */
      }, /* A2_cyl1_DRVS */
      {
         /* [0..1] */ 0.00011309733235975727F, 5.8333336028226768e-07F
         /* 0.00011309733235975727F, 5.8333336028226768e-07F */
      }, /* A4_cyl1_DRVS */
      0.F, /* limit_I */
      1.F, /* rateLim_cyl1 */
      1.F, /* rateLim_DRVS */
      400000.F /* p4 */
   };
   STATIC_LOCAL struct wrist_const_tag wristCtrl_const = {
      0.F, /* sensor_gain */
      0.F, /* A2 */
      0.F, /* A4 */
      0.F, /* f_diff_x */
      0.F, /* rateLim */
      50.F, /* limit_I */
      0.F /* p4 */
   };

   /* SLLocal: Default storage class for local variables | Width: 32 */
   Float32 Se10_Out1[7];
   Float32 Se12_xd[2];
   Float32 Se13_Gain17[7];
   Float32 Se14_Switch[7];
   Float32 Se15_Gain1;
   Float32 Se15_MinMax[2];
   Float32 Se15_MinMax1[2];
   Float32 Se19_Add1;
   Float32 Se19_Divide2;
   Float32 Se1_Add2[2];
   Float32 Se1_Divide[5];
   Float32 Se1_Divide1[5];
   Float32 Se1_Product5[2];
   Float32 Se1_Rate_Limiter_fixed_limit[7];
   Float32 Se1_Subtract5[2];
   Float32 Se1_Subtract6[2];
   Float32 Se20_Add1;
   Float32 Se20_Divide2;
   Float32 Se4_Out1[7];
   Float32 Se5_Out1[7];
   Float32 Se7_Add[2];
   Float32 Se8_Switch;
   Float32 Se8_Switch1;

   /* SLLocal: Default storage class for local variables | Width: 8 */
   Bool Se18_Relational_Operator;
   Bool Se19_LessThanOrEqual;
   Bool Se1_OR;
   Bool Se20_LessThanOrEqual;
   Bool Se2_Relational_Operator1[7];
   Bool Se7_reset[2];

   /* SLLocal: Default storage class for local variables | Width: 32 */
   Float32 Aux_F32;
   Float32 Aux_F32_a;
   Float32 Aux_F32_b;
   Int32 Aux_S32;

   /* SLStaticLocal: Default storage class for static local variables | Width: 32 */
   static Float32 X_Se1_Rate_Limiter_fixed_limit[7] = 
   {
      /* [0..6] */ 0.F, 0.F, 0.F, 0.F, 0.F, 0.F, 0.F
      /* 0.F, 0.F, 0.F, 0.F, 0.F, 0.F, 0.F */
   };
   static Float32 X_Se8_Rate_Limiter = 0.F;
   static Float32 X_Se8_Rate_Limiter1 = 0.F;

   /* SLStaticLocalInit: Default storage class for static local variables with initvalue | Width: 32
    */
   static Float32 X_Se16_Unit_Delay = 0.F;
   static Float32 X_Se17_Unit_Delay = 0.F;
   static Float32 X_Se18_Unit_Delay = 0.F;
   static Float32 X_Se19_startPos = 0.F;
   static Float32 X_Se20_startPos = 0.F;
   static Float32 X_Se21_Unit_Delay = 0.F;
   static Float32 X_Se22_Unit_Delay = 0.F;
   static Float32 X_Se3_Unit_Delay = 0.F;
   static Float32 X_Se6_Unit_Delay[7] = 
   {
      /* [0..6] */ 0.F, 0.F, 0.F, 0.F, 0.F, 0.F, 0.F
      /* 0.F, 0.F, 0.F, 0.F, 0.F, 0.F, 0.F */
   };
   static Float32 X_Se7_Unit_Delay[2] = 
   {
      /* [0..1] */ 0.F, 0.F
      /* 0.F, 0.F */
   };

   /* SLStaticLocalInit: Default storage class for static local variables with initvalue | Width: 8
   */
   static Bool Se1_fingerCtrl_FirstRun = 1;

   /* Sum: fingerCtrl/Add2
      # combined # Rescaler: fingerCtrl/Data Type Conversion7
      # combined # Rescaler: fingerCtrl/Data Type Conversion8 */
   Se1_Add2[0] = ((Float32) *ActPos_cyl1) - ((Float32) fingerCtrl_tuning->cyl1_minPos);
   Se1_Add2[1] = ((Float32) *ActPos_DRVS) - ((Float32) fingerCtrl_tuning->DRVS_minPos);

   /* Sum: fingerCtrl/Subtract6
      # combined # Rescaler: fingerCtrl/Data Type Conversion6
      # combined # Rescaler: fingerCtrl/Data Type Conversion8 */
   Se1_Subtract6[0] = ((Float32) fingerCtrl_tuning->cyl1_maxPos) - ((Float32)
    fingerCtrl_tuning->cyl1_minPos);
   Se1_Subtract6[1] = ((Float32) fingerCtrl_tuning->DRVS_maxPos) - ((Float32)
    fingerCtrl_tuning->DRVS_minPos);

   /* Product: fingerCtrl/Product5 */
   if (Se1_Subtract6[0] != 0.F) {
      Se1_Product5[0] = Se1_Add2[0] / Se1_Subtract6[0];
   }
   else {
      if (Se1_Add2[0] < 0.F) {
         Se1_Product5[0] = tl_FLOAT32NMIN;
      }
      else {
         Se1_Product5[0] = tl_FLOAT32MAX;
      }
   }
   if (Se1_Subtract6[1] != 0.F) {
      Se1_Product5[1] = Se1_Add2[1] / Se1_Subtract6[1];
   }
   else {
      if (Se1_Add2[1] < 0.F) {
         Se1_Product5[1] = tl_FLOAT32NMIN;
      }
      else {
         Se1_Product5[1] = tl_FLOAT32MAX;
      }
   }

   /* Logical: fingerCtrl/OR
      # combined # fingerCtrl/DetectChange_TL/Out1
      # combined # Relational: fingerCtrl/DetectChange_TL/Relational Operator
      # combined # fingerCtrl/DetectChange_TL/In1 */
   Se1_OR = ((Float32) (((Float32) *enable) != X_Se3_Unit_Delay)) != 0;

   /* Unit delay: fingerCtrl/DetectChange_TL/Unit Delay
      # combined # fingerCtrl/DetectChange_TL/In1 */
   X_Se3_Unit_Delay = (Float32) *enable;

   /* Relational: fingerCtrl/bahnplaner/DetectChange_TL2/Relational Operator
      # combined # fingerCtrl/bahnplaner/DetectChange_TL2/In1
      # combined # fingerCtrl/bahnplaner/ena */
   Se18_Relational_Operator = ((Float32) Se1_OR) != X_Se18_Unit_Delay;

   /* Unit delay: fingerCtrl/bahnplaner/DetectChange_TL2/Unit Delay
      # combined # fingerCtrl/bahnplaner/DetectChange_TL2/In1
      # combined # fingerCtrl/bahnplaner/ena */
   X_Se18_Unit_Delay = (Float32) Se1_OR;

   /* Logical: fingerCtrl/bahnplaner/OR
      # combined # fingerCtrl/Integrator1/reset
      # combined # fingerCtrl/bahnplaner/DetectChange_TL1/Out1
      # combined # fingerCtrl/bahnplaner/DetectChange_TL2/Out1
      # combined # fingerCtrl/bahnplaner/DetectChange_TL1/In1
      # combined # fingerCtrl/bahnplaner/desPos */
   Se7_reset[0] = Se18_Relational_Operator || (*desPos_cyl1 != X_Se17_Unit_Delay);

   /* Unit delay: fingerCtrl/bahnplaner/DetectChange_TL1/Unit Delay
      # combined # fingerCtrl/bahnplaner/DetectChange_TL1/In1
      # combined # fingerCtrl/bahnplaner/desPos */
   X_Se17_Unit_Delay = *desPos_cyl1;

   /* Switch: fingerCtrl/bahnplaner/Subsystem/Switch1 */
   if (Se7_reset[0]) {
      /* Switch: fingerCtrl/bahnplaner/Subsystem/Switch1
         # combined # fingerCtrl/bahnplaner/Subsystem/Pos
         # combined # fingerCtrl/bahnplaner/actualPos
         # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem/startPos */
      X_Se19_startPos = Se1_Product5[0];
   }

   /* Sum: fingerCtrl/bahnplaner/Subsystem/Add1
      # combined # fingerCtrl/bahnplaner/Subsystem/desPos
      # combined # fingerCtrl/bahnplaner/desPos
      # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem/startPos */
   Se19_Add1 = *desPos_cyl1 - X_Se19_startPos;

   /* Product: fingerCtrl/bahnplaner/Subsystem/Divide2 */
   if (finger_const.rateLim_cyl1 != 0.F) {
      /* # combined # Abs: fingerCtrl/bahnplaner/Subsystem/Abs1 */
      Se19_Divide2 = ((Float32) fabs((Float64) Se19_Add1)) / finger_const.rateLim_cyl1;
   }
   else {
      /* fingerCtrl/bahnplaner/Subsystem/Divide2: Numerator always greater than or equal to zero. */
      Se19_Divide2 = tl_FLOAT32MAX;
   }

   /* Product: fingerCtrl/bahnplaner/Subsystem/Integrator/Product
      # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem/Integrator/Unit Delay
      # combined # Saturation: fingerCtrl/bahnplaner/Subsystem/Integrator/Saturation
      # combined # Sum: fingerCtrl/bahnplaner/Subsystem/Integrator/Add
      # combined # Logical: fingerCtrl/bahnplaner/Subsystem/Integrator/Logical Operator
      # combined # fingerCtrl/bahnplaner/Subsystem/Integrator/reset
      # combined # Gain: fingerCtrl/bahnplaner/Subsystem/Integrator/Gain */
   X_Se21_Unit_Delay = ((Float32) (!(Se7_reset[0]))) * (0.005F + X_Se21_Unit_Delay);

   /* Relational: fingerCtrl/bahnplaner/Subsystem/LessThanOrEqual
      # combined # fingerCtrl/bahnplaner/Subsystem/Integrator/out
      # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem/Integrator/Unit Delay */
   Se19_LessThanOrEqual = X_Se21_Unit_Delay <= Se19_Divide2;

   /* Logical: fingerCtrl/bahnplaner/OR1
      # combined # fingerCtrl/Integrator1/reset
      # combined # fingerCtrl/bahnplaner/DetectChange_TL/Out1
      # combined # fingerCtrl/bahnplaner/DetectChange_TL2/Out1
      # combined # fingerCtrl/bahnplaner/DetectChange_TL/In1
      # combined # fingerCtrl/bahnplaner/desPos */
   Se7_reset[1] = Se18_Relational_Operator || (*desPos_DRVS != X_Se16_Unit_Delay);

   /* Unit delay: fingerCtrl/bahnplaner/DetectChange_TL/Unit Delay
      # combined # fingerCtrl/bahnplaner/DetectChange_TL/In1
      # combined # fingerCtrl/bahnplaner/desPos */
   X_Se16_Unit_Delay = *desPos_DRVS;

   /* Switch: fingerCtrl/bahnplaner/Subsystem1/Switch1 */
   if (Se7_reset[1]) {
      /* Switch: fingerCtrl/bahnplaner/Subsystem1/Switch1
         # combined # fingerCtrl/bahnplaner/Subsystem1/Pos
         # combined # fingerCtrl/bahnplaner/actualPos
         # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem1/startPos */
      X_Se20_startPos = Se1_Product5[1];
   }

   /* Sum: fingerCtrl/bahnplaner/Subsystem1/Add1
      # combined # fingerCtrl/bahnplaner/Subsystem1/desPos
      # combined # fingerCtrl/bahnplaner/desPos
      # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem1/startPos */
   Se20_Add1 = *desPos_DRVS - X_Se20_startPos;

   /* Product: fingerCtrl/bahnplaner/Subsystem1/Divide2 */
   if (finger_const.rateLim_DRVS != 0.F) {
      /* # combined # Abs: fingerCtrl/bahnplaner/Subsystem1/Abs1 */
      Se20_Divide2 = ((Float32) fabs((Float64) Se20_Add1)) / finger_const.rateLim_DRVS;
   }
   else {
      /* fingerCtrl/bahnplaner/Subsystem1/Divide2: Numerator always greater than or equal to zero.
      */
      Se20_Divide2 = tl_FLOAT32MAX;
   }

   /* Product: fingerCtrl/bahnplaner/Subsystem1/Integrator/Product
      # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem1/Integrator/Unit Delay
      # combined # Saturation: fingerCtrl/bahnplaner/Subsystem1/Integrator/Saturation
      # combined # Sum: fingerCtrl/bahnplaner/Subsystem1/Integrator/Add
      # combined # Logical: fingerCtrl/bahnplaner/Subsystem1/Integrator/Logical Operator
      # combined # fingerCtrl/bahnplaner/Subsystem1/Integrator/reset
      # combined # Gain: fingerCtrl/bahnplaner/Subsystem1/Integrator/Gain */
   X_Se22_Unit_Delay = ((Float32) (!(Se7_reset[1]))) * (0.005F + X_Se22_Unit_Delay);

   /* Relational: fingerCtrl/bahnplaner/Subsystem1/LessThanOrEqual
      # combined # fingerCtrl/bahnplaner/Subsystem1/Integrator/out
      # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem1/Integrator/Unit Delay */
   Se20_LessThanOrEqual = X_Se22_Unit_Delay <= Se20_Divide2;

   /* Switch: fingerCtrl/bahnplaner/Subsystem/Switch2
      fingerCtrl/bahnplaner/Subsystem/Switch2: Omitted comparison with constant. */
   if (Se19_LessThanOrEqual) {
      /* SLLocal: Default storage class for local variables | Width: 32 */
      Float32 Se19_Divide;

      /* Product: fingerCtrl/bahnplaner/Subsystem/Divide */
      if (Se19_Divide2 != 0.F) {
         /* # combined # fingerCtrl/bahnplaner/Subsystem/Integrator/out
            # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem/Integrator/Unit Delay */
         Se19_Divide = X_Se21_Unit_Delay / Se19_Divide2;
      }
      else {
         /* # combined # fingerCtrl/bahnplaner/Subsystem/Integrator/out
            # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem/Integrator/Unit Delay */
         if (X_Se21_Unit_Delay < 0.F) {
            Se19_Divide = tl_FLOAT32NMIN;
         }
         else {
            Se19_Divide = tl_FLOAT32MAX;
         }
      }
      Se19_Divide = Se19_Divide * Se19_Add1;

      /* Switch: fingerCtrl/bahnplaner/Subsystem/Switch2
         # combined # fingerCtrl/bahnplaner/xd
         # combined # fingerCtrl/bahnplaner/Subsystem/y
         # combined # Sum: fingerCtrl/bahnplaner/Subsystem/Add
         # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem/startPos */
      Se12_xd[0] = Se19_Divide + X_Se19_startPos;
   }
   else {
      /* Switch: fingerCtrl/bahnplaner/Subsystem/Switch2
         # combined # fingerCtrl/bahnplaner/xd
         # combined # fingerCtrl/bahnplaner/Subsystem/y
         # combined # fingerCtrl/bahnplaner/Subsystem/desPos
         # combined # fingerCtrl/bahnplaner/desPos */
      Se12_xd[0] = *desPos_cyl1;
   }

   /* Switch: fingerCtrl/bahnplaner/Subsystem1/Switch2
      fingerCtrl/bahnplaner/Subsystem1/Switch2: Omitted comparison with constant. */
   if (Se20_LessThanOrEqual) {
      /* SLLocal: Default storage class for local variables | Width: 32 */
      Float32 Se20_Divide;

      /* Product: fingerCtrl/bahnplaner/Subsystem1/Divide */
      if (Se20_Divide2 != 0.F) {
         /* # combined # fingerCtrl/bahnplaner/Subsystem1/Integrator/out
            # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem1/Integrator/Unit Delay */
         Se20_Divide = X_Se22_Unit_Delay / Se20_Divide2;
      }
      else {
         /* # combined # fingerCtrl/bahnplaner/Subsystem1/Integrator/out
            # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem1/Integrator/Unit Delay */
         if (X_Se22_Unit_Delay < 0.F) {
            Se20_Divide = tl_FLOAT32NMIN;
         }
         else {
            Se20_Divide = tl_FLOAT32MAX;
         }
      }
      Se20_Divide = Se20_Divide * Se20_Add1;

      /* Switch: fingerCtrl/bahnplaner/Subsystem1/Switch2
         # combined # fingerCtrl/bahnplaner/xd
         # combined # fingerCtrl/bahnplaner/Subsystem1/y
         # combined # Sum: fingerCtrl/bahnplaner/Subsystem1/Add
         # combined # Unit delay: fingerCtrl/bahnplaner/Subsystem1/startPos */
      Se12_xd[1] = Se20_Divide + X_Se20_startPos;
   }
   else {
      /* Switch: fingerCtrl/bahnplaner/Subsystem1/Switch2
         # combined # fingerCtrl/bahnplaner/xd
         # combined # fingerCtrl/bahnplaner/Subsystem1/y
         # combined # fingerCtrl/bahnplaner/Subsystem1/desPos
         # combined # fingerCtrl/bahnplaner/desPos */
      Se12_xd[1] = *desPos_DRVS;
   }

   /* Sum: fingerCtrl/Subtract5 */
   Se1_Subtract5[0] = Se12_xd[0] - Se1_Product5[0];
   Se1_Subtract5[1] = Se12_xd[1] - Se1_Product5[1];

   /* Switch: fingerCtrl/KI_reduction/Switch
      fingerCtrl/KI_reduction/Switch: Omitted comparison with constant.
      # combined # Relational: fingerCtrl/KI_reduction/Less Than
      # combined # Abs: fingerCtrl/KI_reduction/Abs
      # combined # fingerCtrl/KI_reduction/e_cyl */
   if (((Float32) fabs((Float64) Se1_Subtract5[0])) < 0.1F) {
      /* Switch: fingerCtrl/KI_reduction/Switch */
      Se8_Switch = 0.1F;
   }
   else {
      /* Switch: fingerCtrl/KI_reduction/Switch */
      Se8_Switch = 1.F;
   }

   /* Switch: fingerCtrl/KI_reduction/Switch1
      fingerCtrl/KI_reduction/Switch1: Omitted comparison with constant.
      # combined # Relational: fingerCtrl/KI_reduction/Less Than1
      # combined # Abs: fingerCtrl/KI_reduction/Abs1
      # combined # fingerCtrl/KI_reduction/e_cyl */
   if (((Float32) fabs((Float64) Se1_Subtract5[1])) < 0.05F) {
      /* Switch: fingerCtrl/KI_reduction/Switch1 */
      Se8_Switch1 = 0.1F;
   }
   else {
      /* Switch: fingerCtrl/KI_reduction/Switch1 */
      Se8_Switch1 = 1.F;
   }

   /* Rate Limiter: fingerCtrl/KI_reduction/Rate Limiter1: First run initialization */
   if (Se1_fingerCtrl_FirstRun) {
      X_Se8_Rate_Limiter = 0.F;
      X_Se8_Rate_Limiter1 = 0.F;
   }

   /* Rate Limiter: fingerCtrl/KI_reduction/Rate Limiter: deviation */
   Aux_F32 = Se8_Switch - X_Se8_Rate_Limiter;
   if (Aux_F32 > 0.025F) {
      /* Rate Limiter: fingerCtrl/KI_reduction/Rate Limiter: limit rising rate */
      X_Se8_Rate_Limiter += 0.025F;
   }
   else {
      if (Aux_F32 < -0.025F) {
         /* Rate Limiter: fingerCtrl/KI_reduction/Rate Limiter: limit falling rate */
         X_Se8_Rate_Limiter += -0.025F;
      }
      else {
         X_Se8_Rate_Limiter = Se8_Switch;
      }
   }

   /* Rate Limiter: fingerCtrl/KI_reduction/Rate Limiter1: deviation */
   Aux_F32 = Se8_Switch1 - X_Se8_Rate_Limiter1;
   if (Aux_F32 > 0.025F) {
      /* Rate Limiter: fingerCtrl/KI_reduction/Rate Limiter1: limit rising rate */
      X_Se8_Rate_Limiter1 += 0.025F;
   }
   else {
      if (Aux_F32 < -0.025F) {
         /* Rate Limiter: fingerCtrl/KI_reduction/Rate Limiter1: limit falling rate */
         X_Se8_Rate_Limiter1 += -0.025F;
      }
      else {
         X_Se8_Rate_Limiter1 = Se8_Switch1;
      }
   }

   /* Sum: fingerCtrl/Integrator1/Add
      # combined # Gain: fingerCtrl/Integrator1/Gain
      # combined # fingerCtrl/Integrator1/in
      # combined # Product: fingerCtrl/Product4
      # combined # Gain: fingerCtrl/Gain1
      # combined # fingerCtrl/KI_reduction/kI
      # combined # Rate Limiter: fingerCtrl/KI_reduction/Rate Limiter: output */
   Se7_Add[0] = (X_Se8_Rate_Limiter * (Se1_Subtract5[0] * fingerCtrl_tuning->I_cyl_drvs[0]) *
    0.005F) + X_Se7_Unit_Delay[0];

   /* Sum: fingerCtrl/Integrator1/Add
      # combined # Gain: fingerCtrl/Integrator1/Gain
      # combined # fingerCtrl/Integrator1/in
      # combined # Product: fingerCtrl/Product4
      # combined # Gain: fingerCtrl/Gain1
      # combined # fingerCtrl/KI_reduction/kI
      # combined # Rate Limiter: fingerCtrl/KI_reduction/Rate Limiter1: output */
   Se7_Add[1] = (X_Se8_Rate_Limiter1 * (Se1_Subtract5[1] * fingerCtrl_tuning->I_cyl_drvs[1]) *
    0.005F) + X_Se7_Unit_Delay[1];

   /* MinMax: fingerCtrl/Integrator1/Saturate/MinMax
      # combined # fingerCtrl/Integrator1/Saturate/In1 */
   if (Se7_Add[0] < wristCtrl_const.limit_I) {
      /* # combined # fingerCtrl/Integrator1/Saturate/In1 */
      Se15_MinMax[0] = Se7_Add[0];
   }
   else {
      Se15_MinMax[0] = wristCtrl_const.limit_I;
   }
   if (Se7_Add[1] < wristCtrl_const.limit_I) {
      /* # combined # fingerCtrl/Integrator1/Saturate/In1 */
      Se15_MinMax[1] = Se7_Add[1];
   }
   else {
      Se15_MinMax[1] = wristCtrl_const.limit_I;
   }

   /* Gain: fingerCtrl/Integrator1/Saturate/Gain1 */
   Se15_Gain1 = wristCtrl_const.limit_I * -1.F;

   /* MinMax: fingerCtrl/Integrator1/Saturate/MinMax1 */
   if (Se15_MinMax[0] > Se15_Gain1) {
      Se15_MinMax1[0] = Se15_MinMax[0];
   }
   else {
      Se15_MinMax1[0] = Se15_Gain1;
   }

   /* Product: fingerCtrl/Integrator1/Product
      # combined # Unit delay: fingerCtrl/Integrator1/Unit Delay
      # combined # fingerCtrl/Integrator1/Saturate/Out1
      # combined # Logical: fingerCtrl/Integrator1/Logical Operator */
   X_Se7_Unit_Delay[0] = ((Float32) (!(Se7_reset[0]))) * Se15_MinMax1[0];

   /* MinMax: fingerCtrl/Integrator1/Saturate/MinMax1 */
   if (Se15_MinMax[1] > Se15_Gain1) {
      Se15_MinMax1[1] = Se15_MinMax[1];
   }
   else {
      Se15_MinMax1[1] = Se15_Gain1;
   }

   /* Product: fingerCtrl/Integrator1/Product
      # combined # Unit delay: fingerCtrl/Integrator1/Unit Delay
      # combined # fingerCtrl/Integrator1/Saturate/Out1
      # combined # Logical: fingerCtrl/Integrator1/Logical Operator */
   X_Se7_Unit_Delay[1] = ((Float32) (!(Se7_reset[1]))) * Se15_MinMax1[1];

   /* Switch: fingerCtrl/Switch
      fingerCtrl/Switch: Omitted comparison with constant. */
   if (*enable) {
      /* SLLocal: Default storage class for local variables | Width: 32 */
      Float32 Se12_vd[2];
      Float32 Se9_Subtract2[2];

      /* Switch: fingerCtrl/bahnplaner/Subsystem1/Switch3
         fingerCtrl/bahnplaner/Subsystem1/Switch3: Omitted comparison with constant. */
      if (Se20_LessThanOrEqual) {
         /* Product: fingerCtrl/bahnplaner/Subsystem1/Divide1 */
         if (Se20_Divide2 != 0.F) {
            /* # combined # Switch: fingerCtrl/bahnplaner/Subsystem1/Switch3
               # combined # fingerCtrl/bahnplaner/vd
               # combined # fingerCtrl/bahnplaner/Subsystem1/v */
            Se12_vd[1] = Se20_Add1 / Se20_Divide2;
         }
         else {
            if (Se20_Add1 < 0.F) {
               /* # combined # Switch: fingerCtrl/bahnplaner/Subsystem1/Switch3
                  # combined # fingerCtrl/bahnplaner/vd
                  # combined # fingerCtrl/bahnplaner/Subsystem1/v */
               Se12_vd[1] = tl_FLOAT32NMIN;
            }
            else {
               /* # combined # Switch: fingerCtrl/bahnplaner/Subsystem1/Switch3
                  # combined # fingerCtrl/bahnplaner/vd
                  # combined # fingerCtrl/bahnplaner/Subsystem1/v */
               Se12_vd[1] = tl_FLOAT32MAX;
            }
         }
      }
      else {
         /* Switch: fingerCtrl/bahnplaner/Subsystem1/Switch3
            # combined # fingerCtrl/bahnplaner/vd
            # combined # fingerCtrl/bahnplaner/Subsystem1/v */
         Se12_vd[1] = 0.F;
      }

      /* Sum: fingerCtrl/Kraft - Druck Umrechnung/Subtract2
         # combined # Product: fingerCtrl/Kraft - Druck Umrechnung/Product
         # combined # fingerCtrl/Kraft - Druck Umrechnung/FpSoll
         # combined # Sum: fingerCtrl/Add1
         # combined # Product: fingerCtrl/Kraft - Druck Umrechnung/Product1
         fingerCtrl/Kraft - Druck Umrechnung/Product1: folded operation multiplication to constant v
         alue 0.233333344112907
         # combined # fingerCtrl/Integrator1/out
         # combined # Unit delay: fingerCtrl/Integrator1/Unit Delay
         # combined # Gain: fingerCtrl/Gain2
         # combined # Gain: fingerCtrl/Gain4
         # combined # Sum: fingerCtrl/Kraft - Druck Umrechnung/Add */
      Se9_Subtract2[1] = 0.23333334411290707F - ((Se12_vd[1] * fingerCtrl_tuning->FF_cyl_drvs[1]) +
       (Se1_Subtract5[1] * fingerCtrl_tuning->P_cyl_drvs[1]) + X_Se7_Unit_Delay[1]) - (100000.F *
       (5.8333336028226768e-07F - finger_const.A2_cyl1_DRVS[1]));

      /* Product: fingerCtrl/Kraft - Druck Umrechnung/Divide */
      if (finger_const.A2_cyl1_DRVS[1] != 0.F) {
         /* # combined # Switch: fingerCtrl/Switch1
            # combined # fingerCtrl/Kraft - Druck Umrechnung/p2Soll
            # combined # TargetLink outport: fingerCtrl/p2d_DRVS */
         *p2d_DRVS = Se9_Subtract2[1] / finger_const.A2_cyl1_DRVS[1];
      }
      else {
         if (Se9_Subtract2[1] < 0.F) {
            /* # combined # Switch: fingerCtrl/Switch1
               # combined # fingerCtrl/Kraft - Druck Umrechnung/p2Soll
               # combined # TargetLink outport: fingerCtrl/p2d_DRVS */
            *p2d_DRVS = tl_FLOAT32NMIN;
         }
         else {
            /* # combined # Switch: fingerCtrl/Switch1
               # combined # fingerCtrl/Kraft - Druck Umrechnung/p2Soll
               # combined # TargetLink outport: fingerCtrl/p2d_DRVS */
            *p2d_DRVS = tl_FLOAT32MAX;
         }
      }

      /* Switch: fingerCtrl/bahnplaner/Subsystem/Switch3
         fingerCtrl/bahnplaner/Subsystem/Switch3: Omitted comparison with constant. */
      if (Se19_LessThanOrEqual) {
         /* Product: fingerCtrl/bahnplaner/Subsystem/Divide1 */
         if (Se19_Divide2 != 0.F) {
            /* # combined # Switch: fingerCtrl/bahnplaner/Subsystem/Switch3
               # combined # fingerCtrl/bahnplaner/vd
               # combined # fingerCtrl/bahnplaner/Subsystem/v */
            Se12_vd[0] = Se19_Add1 / Se19_Divide2;
         }
         else {
            if (Se19_Add1 < 0.F) {
               /* # combined # Switch: fingerCtrl/bahnplaner/Subsystem/Switch3
                  # combined # fingerCtrl/bahnplaner/vd
                  # combined # fingerCtrl/bahnplaner/Subsystem/v */
               Se12_vd[0] = tl_FLOAT32NMIN;
            }
            else {
               /* # combined # Switch: fingerCtrl/bahnplaner/Subsystem/Switch3
                  # combined # fingerCtrl/bahnplaner/vd
                  # combined # fingerCtrl/bahnplaner/Subsystem/v */
               Se12_vd[0] = tl_FLOAT32MAX;
            }
         }
      }
      else {
         /* Switch: fingerCtrl/bahnplaner/Subsystem/Switch3
            # combined # fingerCtrl/bahnplaner/vd
            # combined # fingerCtrl/bahnplaner/Subsystem/v */
         Se12_vd[0] = 0.F;
      }

      /* Sum: fingerCtrl/Kraft - Druck Umrechnung/Subtract2
         # combined # Product: fingerCtrl/Kraft - Druck Umrechnung/Product
         # combined # fingerCtrl/Kraft - Druck Umrechnung/FpSoll
         # combined # Sum: fingerCtrl/Add1
         # combined # Product: fingerCtrl/Kraft - Druck Umrechnung/Product1
         fingerCtrl/Kraft - Druck Umrechnung/Product1: folded operation multiplication to constant v
         alue 45.2389329439029
         # combined # fingerCtrl/Integrator1/out
         # combined # Unit delay: fingerCtrl/Integrator1/Unit Delay
         # combined # Gain: fingerCtrl/Gain2
         # combined # Gain: fingerCtrl/Gain4
         # combined # Sum: fingerCtrl/Kraft - Druck Umrechnung/Add */
      Se9_Subtract2[0] = 45.23893294390291F - ((Se12_vd[0] * fingerCtrl_tuning->FF_cyl_drvs[0]) +
       (Se1_Subtract5[0] * fingerCtrl_tuning->P_cyl_drvs[0]) + X_Se7_Unit_Delay[0]) - (100000.F *
       (0.00011309733235975727F - finger_const.A2_cyl1_DRVS[0]));

      /* Product: fingerCtrl/Kraft - Druck Umrechnung/Divide */
      if (finger_const.A2_cyl1_DRVS[0] != 0.F) {
         /* # combined # Switch: fingerCtrl/Switch
            # combined # TargetLink outport: fingerCtrl/p2d_cyl1
            # combined # fingerCtrl/Kraft - Druck Umrechnung/p2Soll */
         *p2d_cyl1 = Se9_Subtract2[0] / finger_const.A2_cyl1_DRVS[0];
      }
      else {
         if (Se9_Subtract2[0] < 0.F) {
            /* # combined # Switch: fingerCtrl/Switch
               # combined # TargetLink outport: fingerCtrl/p2d_cyl1
               # combined # fingerCtrl/Kraft - Druck Umrechnung/p2Soll */
            *p2d_cyl1 = tl_FLOAT32NMIN;
         }
         else {
            /* # combined # Switch: fingerCtrl/Switch
               # combined # TargetLink outport: fingerCtrl/p2d_cyl1
               # combined # fingerCtrl/Kraft - Druck Umrechnung/p2Soll */
            *p2d_cyl1 = tl_FLOAT32MAX;
         }
      }
   }
   else {
      /* Switch: fingerCtrl/Switch1
         # combined # TargetLink outport: fingerCtrl/p2d_DRVS */
      *p2d_DRVS = 0.F;

      /* Switch: fingerCtrl/Switch
         # combined # TargetLink outport: fingerCtrl/p2d_cyl1 */
      *p2d_cyl1 = 0.F;
   }
   for (Aux_S32 = 0; Aux_S32 < 7; Aux_S32++)
   {
      /* Saturation: fingerCtrl/Saturation */
      if (Se1_desFingerPos[Aux_S32] > 1.F) {
         /* Vector 'Se1_Saturation' replaced by 'Aux_F32' */
         Aux_F32 = 1.F;
      }
      else {
         if (Se1_desFingerPos[Aux_S32] < 0.F) {
            /* Vector 'Se1_Saturation' replaced by 'Aux_F32' */
            Aux_F32 = 0.F;
         }
         else {
            /* Vector 'Se1_Saturation' replaced by 'Aux_F32' */
            Aux_F32 = Se1_desFingerPos[Aux_S32];
         }
      }

      /* Rate Limiter: fingerCtrl/Rate Limiter fixed limit: First run initialization */
      if (Se1_fingerCtrl_FirstRun) {
         X_Se1_Rate_Limiter_fixed_limit[Aux_S32] = 0.F;
      }

      /* Rate Limiter: fingerCtrl/Rate Limiter fixed limit: deviation */
      Aux_F32_a = Aux_F32 - X_Se1_Rate_Limiter_fixed_limit[Aux_S32];
      Aux_F32_b = finger_const.rateLim_finger * 0.005F;
      if (Aux_F32_a > Aux_F32_b) {
         /* Rate Limiter: fingerCtrl/Rate Limiter fixed limit: limit rising rate */
         X_Se1_Rate_Limiter_fixed_limit[Aux_S32] += Aux_F32_b;
      }
      else {
         if (Aux_F32_a < -0.0025F) {
            /* Rate Limiter: fingerCtrl/Rate Limiter fixed limit: limit falling rate */
            X_Se1_Rate_Limiter_fixed_limit[Aux_S32] += -0.0025F;
         }
         else {
            X_Se1_Rate_Limiter_fixed_limit[Aux_S32] = Aux_F32;
         }
      }

      /* Rate Limiter: fingerCtrl/Rate Limiter fixed limit: output */
      Se1_Rate_Limiter_fixed_limit[Aux_S32] = X_Se1_Rate_Limiter_fixed_limit[Aux_S32];

      /* Relational: fingerCtrl/Abschaltung/Relational Operator1
         # combined # fingerCtrl/Abschaltung/desFingerPos */
      Se2_Relational_Operator1[Aux_S32] = Se1_Rate_Limiter_fixed_limit[Aux_S32] <=
       9.9999997473787516e-06F;
   }

   /* fingerCtrl/I/Out1 */
   Se5_Out1[0] = fingerCtrl_tuning->I_small;
   Se5_Out1[1] = fingerCtrl_tuning->I_small;
   Se5_Out1[2] = fingerCtrl_tuning->I_small;
   Se5_Out1[3] = fingerCtrl_tuning->I_small;
   Se5_Out1[4] = fingerCtrl_tuning->I_big;
   Se5_Out1[5] = fingerCtrl_tuning->I_big;
   Se5_Out1[6] = fingerCtrl_tuning->I_big;
   for (Aux_S32 = 0; Aux_S32 < 5; Aux_S32++)
   {
      /* Sum: fingerCtrl/Subtract
         Vector 'Se1_Subtract' replaced by 'Aux_F32'
         # combined # Rescaler: fingerCtrl/Data Type Conversion
         # combined # Rescaler: fingerCtrl/Data Type Conversion1 */
      Aux_F32 = Se1_TopFingerSensors[Aux_S32] - ((Float32)
       fingerCtrl_tuning->minTopFingerPos[Aux_S32]);

      /* Sum: fingerCtrl/Subtract2
         Vector 'Se1_Subtract2' replaced by 'Aux_F32_a'
         # combined # Rescaler: fingerCtrl/Data Type Conversion2
         # combined # Rescaler: fingerCtrl/Data Type Conversion1 */
      Aux_F32_a = ((Float32) fingerCtrl_tuning->maxTopFingerPos[Aux_S32]) - ((Float32)
       fingerCtrl_tuning->minTopFingerPos[Aux_S32]);

      /* Product: fingerCtrl/Divide1 */
      if (Aux_F32_a != 0.F) {
         Se1_Divide1[Aux_S32] = Aux_F32 / Aux_F32_a;
      }
      else {
         if (Aux_F32 < 0.F) {
            Se1_Divide1[Aux_S32] = tl_FLOAT32NMIN;
         }
         else {
            Se1_Divide1[Aux_S32] = tl_FLOAT32MAX;
         }
      }

      /* Sum: fingerCtrl/Subtract1
         Vector 'Se1_Subtract1' replaced by 'Aux_F32'
         # combined # Rescaler: fingerCtrl/Data Type Conversion3
         # combined # Rescaler: fingerCtrl/Data Type Conversion4 */
      Aux_F32 = Se1_BotFingerSensors[Aux_S32] - ((Float32)
       fingerCtrl_tuning->minBotFingerPos[Aux_S32]);

      /* Sum: fingerCtrl/Subtract3
         Vector 'Se1_Subtract3' replaced by 'Aux_F32_a'
         # combined # Rescaler: fingerCtrl/Data Type Conversion5
         # combined # Rescaler: fingerCtrl/Data Type Conversion4 */
      Aux_F32_a = ((Float32) fingerCtrl_tuning->maxBotFingerPos[Aux_S32]) - ((Float32)
       fingerCtrl_tuning->minBotFingerPos[Aux_S32]);

      /* Product: fingerCtrl/Divide */
      if (Aux_F32_a != 0.F) {
         Se1_Divide[Aux_S32] = Aux_F32 / Aux_F32_a;
      }
      else {
         if (Aux_F32 < 0.F) {
            Se1_Divide[Aux_S32] = tl_FLOAT32NMIN;
         }
         else {
            Se1_Divide[Aux_S32] = tl_FLOAT32MAX;
         }
      }
   }

   /* Switch: fingerCtrl/reOrderSignals/Switch */
   if (finger_const.useMean > 0.F) {
      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # fingerCtrl/reOrderSignals/TopPos */
      Se14_Switch[0] = Se1_Divide1[0];

      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # fingerCtrl/reOrderSignals/BotPos */
      Se14_Switch[1] = Se1_Divide[0];

      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # fingerCtrl/reOrderSignals/TopPos */
      Se14_Switch[2] = Se1_Divide1[1];

      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # fingerCtrl/reOrderSignals/BotPos */
      Se14_Switch[3] = Se1_Divide[1];

      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # Gain: fingerCtrl/reOrderSignals/Gain
         # combined # Sum: fingerCtrl/reOrderSignals/Add
         # combined # fingerCtrl/reOrderSignals/BotPos
         # combined # fingerCtrl/reOrderSignals/TopPos */
      Se14_Switch[4] = (Se1_Divide1[2] + Se1_Divide[2]) * 0.5F;

      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # Gain: fingerCtrl/reOrderSignals/Gain1
         # combined # Sum: fingerCtrl/reOrderSignals/Add1
         # combined # fingerCtrl/reOrderSignals/BotPos
         # combined # fingerCtrl/reOrderSignals/TopPos */
      Se14_Switch[5] = (Se1_Divide1[3] + Se1_Divide[3]) * 0.5F;

      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # Gain: fingerCtrl/reOrderSignals/Gain2
         # combined # Sum: fingerCtrl/reOrderSignals/Add2
         # combined # fingerCtrl/reOrderSignals/BotPos
         # combined # fingerCtrl/reOrderSignals/TopPos */
      Se14_Switch[6] = (Se1_Divide1[4] + Se1_Divide[4]) * 0.5F;
   }
   else {
      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # fingerCtrl/reOrderSignals/TopPos */
      Se14_Switch[0] = Se1_Divide1[0];

      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # fingerCtrl/reOrderSignals/BotPos */
      Se14_Switch[1] = Se1_Divide[0];

      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # fingerCtrl/reOrderSignals/TopPos */
      Se14_Switch[2] = Se1_Divide1[1];

      /* Switch: fingerCtrl/reOrderSignals/Switch
         # combined # fingerCtrl/reOrderSignals/BotPos */
      Se14_Switch[3] = Se1_Divide[1];
      Se14_Switch[4] = Se1_Divide[2];
      Se14_Switch[5] = Se1_Divide[3];
      Se14_Switch[6] = Se1_Divide[4];
   }

   /* fingerCtrl/P/Out1 */
   Se10_Out1[0] = fingerCtrl_tuning->P_small;
   Se10_Out1[1] = fingerCtrl_tuning->P_small;
   Se10_Out1[2] = fingerCtrl_tuning->P_small;
   Se10_Out1[3] = fingerCtrl_tuning->P_small;
   Se10_Out1[4] = fingerCtrl_tuning->P_big;
   Se10_Out1[5] = fingerCtrl_tuning->P_big;
   Se10_Out1[6] = fingerCtrl_tuning->P_big;

   /* fingerCtrl/FF/Out1 */
   Se4_Out1[0] = fingerCtrl_tuning->FF_small;
   Se4_Out1[1] = fingerCtrl_tuning->FF_small;
   Se4_Out1[2] = fingerCtrl_tuning->FF_small;
   Se4_Out1[3] = fingerCtrl_tuning->FF_small;
   Se4_Out1[4] = fingerCtrl_tuning->FF_big;
   Se4_Out1[5] = fingerCtrl_tuning->FF_big;
   Se4_Out1[6] = fingerCtrl_tuning->FF_big;
   for (Aux_S32 = 0; Aux_S32 < 7; Aux_S32++)
   {
      /* Sum: fingerCtrl/Subtract4
         Vector 'Se1_Subtract4' replaced by 'Aux_F32'
         # combined # fingerCtrl/reOrderSignals/FingerPos */
      Aux_F32 = Se1_Rate_Limiter_fixed_limit[Aux_S32] - Se14_Switch[Aux_S32];

      /* Sum: fingerCtrl/Integrator/Add
         Vector 'Se6_Add' replaced by 'Aux_F32_a'
         # combined # Gain: fingerCtrl/Integrator/Gain
         # combined # fingerCtrl/Integrator/in
         # combined # Product: fingerCtrl/Product */
      Aux_F32_a = (Se5_Out1[Aux_S32] * Aux_F32 * 0.005F) + X_Se6_Unit_Delay[Aux_S32];

      /* Saturation: fingerCtrl/Integrator/Saturation */
      if (Aux_F32_a > 0.4F) {
         /* Vector 'Se6_Saturation' replaced by 'Aux_F32_b' */
         Aux_F32_b = 0.4F;
      }
      else {
         if (Aux_F32_a < -0.4F) {
            /* Vector 'Se6_Saturation' replaced by 'Aux_F32_b' */
            Aux_F32_b = -0.4F;
         }
         else {
            /* Vector 'Se6_Saturation' replaced by 'Aux_F32_b' */
            Aux_F32_b = Aux_F32_a;
         }
      }

      /* Product: fingerCtrl/Integrator/Product
         # combined # Unit delay: fingerCtrl/Integrator/Unit Delay
         # combined # Logical: fingerCtrl/Integrator/Logical Operator */
      X_Se6_Unit_Delay[Aux_S32] = ((Float32) ((!(*Se1_reset)) &&
       (Se1_Rate_Limiter_fixed_limit[Aux_S32] > 9.9999997473787516e-06F))) * Aux_F32_b;

      /* Gain: fingerCtrl/bar2Pa/Gain17
         # combined # Sum: fingerCtrl/bar2Pa/Add
         # combined # fingerCtrl/bar2Pa/bar
         # combined # Product: fingerCtrl/Product3
         # combined # Sum: fingerCtrl/Add
         # combined # Product: fingerCtrl/Product2
         # combined # Product: fingerCtrl/Product1
         # combined # fingerCtrl/Integrator/out
         # combined # Unit delay: fingerCtrl/Integrator/Unit Delay */
      Se13_Gain17[Aux_S32] = (((X_Se6_Unit_Delay[Aux_S32] + (Aux_F32 * Se10_Out1[Aux_S32]) +
       (Se1_Rate_Limiter_fixed_limit[Aux_S32] * Se4_Out1[Aux_S32])) * finger_const.ctrlGain) + 1.F)
       * 100000.F;
   }

   /* Switch: fingerCtrl/Abschaltung/Switch7
      fingerCtrl/Abschaltung/Switch7: Omitted comparison with constant. */
   if (Se2_Relational_Operator1[0]) {
      /* Switch: fingerCtrl/Abschaltung/Switch7
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des */
      Se1_pFinger_des[0] = 100000.F;
   }
   else {
      /* Switch: fingerCtrl/Abschaltung/Switch7
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des
         # combined # fingerCtrl/Abschaltung/pFinger_des_in
         # combined # fingerCtrl/bar2Pa/Pa */
      Se1_pFinger_des[0] = Se13_Gain17[0];
   }

   /* Switch: fingerCtrl/Abschaltung/Switch3
      fingerCtrl/Abschaltung/Switch3: Omitted comparison with constant. */
   if (Se2_Relational_Operator1[1]) {
      /* Switch: fingerCtrl/Abschaltung/Switch3
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des */
      Se1_pFinger_des[1] = 100000.F;
   }
   else {
      /* Switch: fingerCtrl/Abschaltung/Switch3
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des
         # combined # fingerCtrl/Abschaltung/pFinger_des_in
         # combined # fingerCtrl/bar2Pa/Pa */
      Se1_pFinger_des[1] = Se13_Gain17[1];
   }

   /* Switch: fingerCtrl/Abschaltung/Switch4
      fingerCtrl/Abschaltung/Switch4: Omitted comparison with constant. */
   if (Se2_Relational_Operator1[2]) {
      /* Switch: fingerCtrl/Abschaltung/Switch4
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des */
      Se1_pFinger_des[2] = 100000.F;
   }
   else {
      /* Switch: fingerCtrl/Abschaltung/Switch4
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des
         # combined # fingerCtrl/Abschaltung/pFinger_des_in
         # combined # fingerCtrl/bar2Pa/Pa */
      Se1_pFinger_des[2] = Se13_Gain17[2];
   }

   /* Switch: fingerCtrl/Abschaltung/Switch1
      fingerCtrl/Abschaltung/Switch1: Omitted comparison with constant. */
   if (Se2_Relational_Operator1[3]) {
      /* Switch: fingerCtrl/Abschaltung/Switch1
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des */
      Se1_pFinger_des[3] = 100000.F;
   }
   else {
      /* Switch: fingerCtrl/Abschaltung/Switch1
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des
         # combined # fingerCtrl/Abschaltung/pFinger_des_in
         # combined # fingerCtrl/bar2Pa/Pa */
      Se1_pFinger_des[3] = Se13_Gain17[3];
   }

   /* Switch: fingerCtrl/Abschaltung/Switch2
      fingerCtrl/Abschaltung/Switch2: Omitted comparison with constant. */
   if (Se2_Relational_Operator1[4]) {
      /* Switch: fingerCtrl/Abschaltung/Switch2
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des */
      Se1_pFinger_des[4] = 100000.F;
   }
   else {
      /* Switch: fingerCtrl/Abschaltung/Switch2
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des
         # combined # fingerCtrl/Abschaltung/pFinger_des_in
         # combined # fingerCtrl/bar2Pa/Pa */
      Se1_pFinger_des[4] = Se13_Gain17[4];
   }

   /* Switch: fingerCtrl/Abschaltung/Switch5
      fingerCtrl/Abschaltung/Switch5: Omitted comparison with constant. */
   if (Se2_Relational_Operator1[5]) {
      /* Switch: fingerCtrl/Abschaltung/Switch5
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des */
      Se1_pFinger_des[5] = 100000.F;
   }
   else {
      /* Switch: fingerCtrl/Abschaltung/Switch5
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des
         # combined # fingerCtrl/Abschaltung/pFinger_des_in
         # combined # fingerCtrl/bar2Pa/Pa */
      Se1_pFinger_des[5] = Se13_Gain17[5];
   }

   /* Switch: fingerCtrl/Abschaltung/Switch6
      fingerCtrl/Abschaltung/Switch6: Omitted comparison with constant. */
   if (Se2_Relational_Operator1[6]) {
      /* Switch: fingerCtrl/Abschaltung/Switch6
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des */
      Se1_pFinger_des[6] = 100000.F;
   }
   else {
      /* Switch: fingerCtrl/Abschaltung/Switch6
         # combined # fingerCtrl/Abschaltung/pFinger_des_out
         # combined # TargetLink outport: fingerCtrl/pFinger_des
         # combined # fingerCtrl/Abschaltung/pFinger_des_in
         # combined # fingerCtrl/bar2Pa/Pa */
      Se1_pFinger_des[6] = Se13_Gain17[6];
   }

   /* fingerCtrl: Reset of the first run state */
   Se1_fingerCtrl_FirstRun = 0;
}

/*------------------------------------------------------------------------------------------------*\
  MODULE LOCAL FUNCTION DEFINITIONS
\*------------------------------------------------------------------------------------------------*/
#ifdef __cplusplus
}
#endif

#endif /* FINGERCTRL_C */
/*------------------------------------------------------------------------------------------------*\
  END OF FILE
\*------------------------------------------------------------------------------------------------*/
